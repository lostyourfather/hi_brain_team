<?xml version="1.0" encoding="windows-1251" standalone="yes"?><?mso-application progid="Word.Document"?><w:wordDocument xmlns:w="http://schemas.microsoft.com/office/word/2003/wordml" xmlns:wx="http://schemas.microsoft.com/office/word/2003/auxHint"><w:fonts><w:defaultFonts w:ascii="Times New Roman" /></w:fonts> <w:styles><w:style w:type="paragraph" w:default="on" w:styleId="a"><w:rPr><w:sz w:val="24"/></w:rPr></w:style></w:styles> <w:docPr><w:view w:val="print"/><w:zoom w:percent="100"/></w:docPr><w:body>
<w:p><w:pPr><w:spacing w:before="0" w:after="0"  w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t>Министерство науки и высшего образования Российской Федерации</w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:before="0" w:after="0"  w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t>Федеральное государственное автономное образовательное учреждение</w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:before="0" w:after="0"  w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t>высшего образования</w:t></w:r></w:p>
<w:p><w:pPr><w:pBdr><w:bottom w:val="single" w:sz="4" wx:bdrwidth="10" w:space="1" w:color="auto"/></w:pBdr><w:jc w:val="center"/></w:pPr><w:r><w:t>«Национальный исследовательский ядерный университет «МИФИ»</w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:before="0" w:after="0"  w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:line="360" w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t>ИНСТИТУТ ИНТЕЛЛЕКТУАЛЬНЫХ КИБЕРНЕТИЧЕСКИХ СИСТЕМ</w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:line="360" w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t>КАФЕДРА КИБЕРНЕТИКИ</w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:line="360" w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:line="360" w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t></w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>МЕТОДИЧЕСКИЕ УКАЗАНИЯ ДЛЯ СТУДЕНТОВ</w:t></w:r><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:line="360" w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t></w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>ПО ДИСЦИПЛИНЕ</w:t></w:r><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:pBdr><w:bottom w:val="single" w:sz="4" wx:bdrwidth="10" w:space="1" w:color="auto"/></w:pBdr><w:jc w:val="center"/></w:pPr><w:r><w:t></w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>Параллельные вычисления</w:t></w:r><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:line="360" w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:tbl><w:tblPr><w:jc w:val="center"/><w:tblCellMar><w:top w:w="0" w:type="dxa"/><w:bottom w:w="0" w:type="dxa"/><w:left w:w="108" w:type="dxa"/><w:right w:w="108" w:type="dxa"/></w:tblCellMar></w:tblPr><w:tblGrid />
<w:tr><w:tc><w:p><w:r><w:t>Направление подготовки (специальность)</w:t></w:r></w:p></w:tc><w:tc><w:p><w:r><w:t></w:t></w:r><w:r><w:rPr><w:u w:val="single"/></w:rPr><w:t> 09.04.04 Программная инженерия </w:t></w:r><w:r><w:t></w:t></w:r></w:p></w:tc></w:tr>
<w:tr><w:tc><w:p><w:r><w:t>Профиль подготовки</w:t></w:r></w:p></w:tc><w:tc><w:p><w:r><w:t></w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>[при его наличии]</w:t></w:r><w:r><w:t></w:t></w:r></w:p></w:tc></w:tr>
<w:tr><w:tc><w:p><w:r><w:t>Наименование образовательной программы (специализация)</w:t></w:r></w:p></w:tc><w:tc><w:p><w:r><w:t></w:t></w:r><w:r><w:rPr><w:u w:val="single"/></w:rPr><w:t> Методы высокотехнологичной разработки сложных программных систем (реализуется совместно с НАО "Алма-атинский университет энергетики и связи" (АУЭС),</w:t></w:r></w:p><w:p><w:r><w:t>Технологии разработки высококритичных кибернетических систем </w:t></w:r><w:r><w:t></w:t></w:r></w:p></w:tc></w:tr>
<w:tr><w:tc><w:p><w:r><w:t>Квалификация (степень) выпускника</w:t></w:r></w:p></w:tc><w:tc><w:p><w:r><w:t></w:t></w:r><w:r><w:rPr><w:u w:val="single"/></w:rPr><w:t> магистр </w:t></w:r><w:r><w:t></w:t></w:r></w:p></w:tc></w:tr>
<w:tr><w:tc><w:p><w:r><w:t>Форма обучения</w:t></w:r></w:p></w:tc><w:tc><w:p><w:r><w:t></w:t></w:r><w:r><w:rPr><w:u w:val="single"/></w:rPr><w:t> очная </w:t></w:r><w:r><w:t></w:t></w:r></w:p></w:tc></w:tr>
</w:tbl>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:before="0" w:after="0"  w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t></w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>АННОТАЦИЯ</w:t></w:r><w:r><w:t></w:t><w:cr /></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>В курсе “Параллельные вычисления” изучаются теоретические основы построения параллельных алгоритмов и их реализации на базовых параллельных структурах.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Основное внимание уделено развитию “параллельного“ мышления, использованию каскадных функций и специфических механизмов для параллельных структур.</w:t></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:before="0" w:after="0"  w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t></w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>СТРУКТУРА ДИСЦИПЛИНЫ</w:t></w:r><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t>	Общая трудоемкость дисциплины составляет 4 кр., 144 час. </w:t></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t>	Лекции: 16 час. </w:t></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t>	Практические занятия/семинары: 16 час. </w:t></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t>	Лабораторные работы: 0 час. </w:t></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t></w:t></w:r></w:p>

<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:before="0" w:after="0"  w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t></w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>МЕТОДИЧЕСКИЕ УКАЗАНИЯ</w:t></w:r><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:before="0" w:after="0"  w:line-rule="auto"/><w:jc w:val="center"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
<w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Целью практикума является усвоение и закрепление теоретического материала курса и приобретение практических навыков разработки параллельных алгоритмов и написания параллельных программ.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> Параллельных программы реализуются на языке АДА. Этот паскалеподобный язык содержит высокоуровневые средства для описания параллельных процессов, что облегчает написание и отладку параллельных программ.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> Практикум состоит из четырех (трех – в зависимости от усвоения материала) работ, каждая из которых содержит индивидуальные задания. Гипотетически редполагается, что в распоряжении студента имеется вычислительная система с большим количеством процессоров и блоков памяти. Требуется разработать такой алгоритм решения предложенных задач и реализовать такую параллельную программу, которая сможет максимально загрузить процессоры полезной работой по решению задач и по возможности равномерно распределить нагрузку. Другими словами, нужно построить высокопараллельный алгоритм, который радикально повышает скорость решения задачи.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> В большинстве случаев требуется, чтобы разработанная программа являлась общим решением задачи и имела, по крайней мере, два независимых параметра Р- число процессоров и N –размерность обрабатываемых данных (например, размерность матриц или одномерных массивов).</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> Предъявляемый для сдачи вариант программы может обрабатывать входные данные небольшого объема, но, тем не менее, программа должна осуществлять общее решение поставленной задачи. Так не допускается, чтобы программа правильно работала только при выполнении условия N=P.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> Предполагается, что программа реализуется на вычислительной системе одного из следующих трех видов </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>1. Параллельная система с непосредственными связями между процессорам и.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>2. Гиперкубическая система</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>3. Векторный процессор.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>4. Систоллическая структура.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> В первом случае процессоры могут работать по индивидуальной программе и обрабатывать свои собственные данные. Процессоры имеют доступ друг к другу, к локальной памяти друг друга и к главной памяти системы. Для краткости, мы будем называть эту структуру параллельные процессоры, хотя все три архитектуры содержат параллельные процессоры.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> Во второй архитектуре процессоры находятся в узлах гиперкуба k-ого порядка и имеют непосредственные связи только с k процессорами, ближайшими по одной из k размерностей гиперкуба. Таким образом, не любые два процессора имеют непосредственные связи друг с другом, и, в общем случае, передача данных из одного процессора в другой проходит через промежуточные процессоры. Эта система должна иметь средства коммутации и управления для прокладывания пути из любого процессора в любой.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>В третьей архитектуре процессоры работают под жестким управлением и в данный момент времени все выполняют одну и ту же команду. Процессоры, входящие в процессорную матрицу, получают данные из локальных регистров или локальных регистров и не имеют непосредственного доступа к главной памяти и другим ресурсам системы в частности к системе ввода-вывода. В большинстве задач данной работы она будет пониматься более узко, а именно как векторный процессор.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>В четвёртом случае система представляет собой сеть процессоров, каждый из которых может обмениваться информацией только с соседними процессорами, причем этот обмен реализуется при помощи специальной аппаратуры, в результате чего он не занимает процессорного времени. Процессоры сети наделены локальной памятью, но не имеют доступа к главной памяти системы. Связь с главной памятью системы осуществляет управляющий компьютер (host), который связан с первым процессором сети.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Предполагается, что задания первой работы реализуются на системе с архитектурой параллельные процессоры (первый вариант). Вид системы, на которой реализуется задания второй и третьей работы, задается в соответствующих заданиях.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Первая работа содержит задачи, в решении которых еще не используются специальные функции и алгоритмы. На ней студент осваивает программирование параллельных процессов на языке АДА и основные подходы к построению параллельных алгоритмов. В основном задания посвящены различным приближенным методам нахождения корней функции, методам приближенного вычисления интегралов и некоторым классическим задача по программированию.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Вторая работа связана с методами параллельного умножения матриц, механизмами бесконфликтного доступа к векторной памяти, с моделированием работы параллельных вычислительных систем различных типов и использованием специальных функций.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Третья работа посвящена параллельным и векторным методам решения систем линейных уравнений и другим задачам линейной алгебры.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Примеры параллельных программ приводятся на лекциях и семинарах.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Разработка параллельного алгоритма и программы включает следующие основные этапы.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>1. Декомпозиция задачи на подзадачи меньшей размерности, которые можно выполнять параллельно (Partition). Это разбиение должно обеспечить достижение определенного порядка временной сложности. Если размерность задачи N, то оценками временной сложности для практически используемых алгоритмов могут служить следующие выражения o(N2), o(N), o(Nlog N), o(log N). Декомпозиция задачи снижает ее реальную размерность до величины (N/P) и позволяет достичь требуемой оценки временной сложности.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>2. Определение способа получения общего результата из частичных результатов, полученных путем выполнения подзадач.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>3. Выбор схемы коммуникаций и способа синхронизации параллельных процессов. Принятые здесь решения должны обеспечить корректность выполняемых вычислений и исключение тупиковых ситуаций. </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>4. Склеивание (agglomeration). Если необходимо, подзадачи объединяются в более крупные с тем, чтобы удовлетворить требованиям по производительности и доступному объему аппаратуры.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>5. Раскладка процессов по процессорам (mapping).</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Декомпозицию (или распределение работы между процессами) подразделяют на статическую и динамическую. При статической декомпозиции работу делят между процессами заранее, до начала обработки, стремясь равномерно загрузить процессы и как можно дольше сохранять большую их загрузку. Для этого этапа существует другое название-балансировка нагрузки. При динамической балансировке нагрузки задания выдает некий центральный процесс, который обычно называют Master, в ответ на запросы освободившихся рабочих задач (workers).</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Студент должен изучить теоретический материал, относящийся к теме задания, разработать параллельные алгоритмы решения полученных им задач, написать и отладить параллельную программу и сдать ее преподавателю в течение семестра. Варианты программ, приведенные на лекциях и семинарах могут использоваться только как фрагменты заданий. но не как задания целиком.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Требования к построению и оформлению программы</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>1. Программа должна использовать такие конструкции языка АДА, которые обеспечивают параллелизм работы процессов.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>2. Построение программы должно следовать общему принципу, заложенному в модели параллелизма языка АДА, согласно которому пассивные процессы не потребляют ресурсов процессоров. Поэтому не допускаются реализации синхронизации процессов за счет введения временных задержек и процессов ожидания событий путем циклического опроса некоторых признаков.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>3. Программа должна выводить протокол работы основных процессов, отражающий следующие этапы : старт процесса, получение входных данных, вывод результатов, сообщение о завершении работы. Протокол должен подтверждать наличие параллелизма в работе программы.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>4. Работа программы должна демонстрироваться на специально подготовленных тестовых данных небольшого объема. Форма вывода результатов должна облегчать установление факта их правильности.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>5. При проведении приближенных вычислений программа должна выводить как полученные результаты, так и эталонные значения с достаточным количеством значащих разрядов. Это является подтверждением достижения необходимой точности.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>6. При сдаче программы студент должен суметь объяснить как принцип работы программы, так и назначение, и работу отдельных ее конструкций.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>7. Студент должен обосновать достижение уровня временной сложности, на которую ориентирована данная реализация программы. Поскольку в языке АДА отсутствуют средства одновременного запуска процессов, и одновременной пересылки данных многим процессам (режим broadcast), имеющиеся во многих других системах, то соответствующие циклы в программе можно не учитывать при оценке ее временной сложности.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Примеры программ.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Приведенные примеры демонстрируют основные подходы к решению задач и использование средств языка АДА. Рассмотренные задачи являются заведомо упрощенными и не могут быть использованы в качестве примеров решения домашних заданий.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Задача 1. Построить параллельный алгоритм и написать параллельную программу для нахождения с заданной точностью корня функции f(x) на отрезке [a, b] методом дихотомии (бисекции), если известно, что на данном отрезке существует точно один корень.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Последовательный алгоритм циклически делит интервал пополам, определяет в какой половине лежит корень и уменьшает интервал путем соответствующего сдвига одной из его границ. Цикл продолжает свою работу до тех пор, пока длина интервала не станет меньше заданной, или корень не окажется на границе интервала.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Декомпозиция. Пусть имеется Р процессов. Разобьем интервал [a, b] на Р равных отрезков. Каждый процесс обрабатывает свой отрезок и определяет, находится ли корень в пределах его отрезке. Для этого он вычисляет значения функции на границах отрезка и проверяет, отличаются ли знаки этих значений.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Синхронизация. Если некий процесс определил, что корень находится в пределах его отрезка, то он передает процессу Master значения границ отрезка. Поскольку такой отрезок по условию задачи только один, то процесс Master принимает только одно сообщение в данном цикле. Но, если корень окажется на границе отрезка, то сообщения могут прислать два соседних процесса.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Чтобы преодолеть эту неоднозначность, сохранив условие приема только одного сообщения процессом Master, поступим следующим образом. Пусть все процессы проверяют наличие корня только на одной из границ отрезка, например, на левой границе. Но тогда правую границу интервала не проверяет ни один из рабочих процессов. Это может на себя взять процесс Master. Таким образом, задача синхронизации решена.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Получив границы нового интервала, процесс Master проверяет достигнута ли необходимая точность и, если нет, то вновь делит полученный интервал на Р отрезков и передает их рабочим процессам.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Это решение позволяет загрузить произвольно большое число процессоров, причем все они работают в течение всего времени работы программы, что дает возможность существенно уменьшить время решения задачи. Текст программы приведен ниже.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>with ADA.text_io,ada.integer_text_io,ada.float_text_io;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> use ADA.text_io,ada.integer_text_io,ada.float_text_io;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>-- with Gnat.IO ; use Gnat.IO;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>procedure dechot1 is </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>z:float;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>nprog:integer := 9;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>-- a,b: float;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>function dechotomy(l,r,epsilon:float) return float is</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>res: float;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>task type solver is</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>entry ranges(l,r: float);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end solver;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>solvers:array(0..nprog-1) of solver;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>task master is</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>entry interval(l_r,r_r: float);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>entry answer(l_range,r_range:float);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>entry result(res:out float);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end master;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>task body solver is</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>-- x,x1,x2,x3,x4,a:float;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>RR,LL : float;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>function f(x:float) return float is</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>begin </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>return (2.0*x-15.0); </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end f;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>function g(x:float) return float is</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>begin</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>return (2.0*x-110.0);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end g;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>begin</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>loop</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>select </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>accept ranges (l,r:float) do</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>LL:=l;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>RR:=r;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end ranges;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put("LL= "); put(LL,10,9);new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put("RR= "); put(RR,10,9);new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>if f(LL)=0.0 then master.answer(LL,LL); end if;   </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>if (f(LL)&lt;0.0) XOR (f(RR)&lt;0.0) then </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>master.answer(LL,RR); end if;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>OR</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>terminate;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end select;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end loop;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end solver;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>task body master is</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>left_r,rigth_r:float;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>d,eps:float;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>k:integer;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>function f(x:float) return float is</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>begin </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>return (2.0*x-15.0); </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end f;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>begin</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>accept interval (l_r,r_r:float)  do</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>left_r:=l_r;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>rigth_r:=r_r;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end interval;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put("!-left_r:");put(left_r);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put("!-rigth_r");put(rigth_r);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>while (abs(rigth_r-left_r)&gt;epsilon) and (abs(f(rigth_r))&gt;epsilon) </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>loop</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>d:=abs(rigth_r-left_r)/float(nprog);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>for k in 0..nprog-1 loop</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>solvers(k).ranges(left_r+d*float(k),left_r+d*float(k+1));</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end loop;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>accept answer(l_range,r_range:float) do</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>left_r:=l_range;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>rigth_r:=r_range;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end answer;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put(";-=-;");new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put("left_r:");put(left_r,10,9);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put("rigth_r");put(rigth_r,10,9);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put("_!_");new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end loop; -- while</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put("!!!!");</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>accept result(res: out float) do</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>res:=left_r;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end result;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end master;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>begin</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>--put("-! start");new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>master.interval(l,r);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>--put("-! interval done");new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>master.result(res);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>--put("-! exit");new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>return res;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end dechotomy;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>begin</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>z:=dechotomy (0.0,10.0,0.00001);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put("Answer:");</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put(z);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end dechot1; </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Рабочие задачи представлены в программе массивом Solvers задач Solver. Поскольку число итераций заранее не известно, прием отрезков задачами Solver осуществляется в цикле с использованием оператора Select. Выход из цикла произойдет по срабатыванию альтернативы terminate, когда задача Master найдет решение, выйдет из цикла, и перестанет обращаться к рабочим задачам.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> Задача Master работает в цикле, проверяя условие достижения заданной точности или появления корня на правой границе интервала. Она определяет длину отрезка d и передает начала и концы отрезков всем задачам Solver, затем принимает по входу answer величины начала и конца отрезка, содержащего корень, от одной из задач Solver. После выхода из цикла она возвращает результат по входу result функции dechotomy.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> Задача 2. Построить параллельный алгоритм и написать параллельную программу для вычисления с заданной точностью интеграла функции f(x) на интервале</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> [a,b], используя метод Ньютона-Котеса третьего порядка (метод Симпсона ).</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> Приближенное интегрирование относится к задачам с так называемым геометрическим параллелизмом. Интервал интегрирования можно разбить на произвольное число отрезков и выполнить интегрирование функции на этих отрезках с помощью отдельных процессов, результаты работы которых, потом сложить.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Декомпозиция. Пусть имеется 3Р процессов. Разделим [a,b] на Р отрезков, с каждым из которых свяжем 3 процесса. Составная квадратурная формула для метода Симпсона имеет следующий вид :</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>  </w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>где h - величина шага, а fi значение функции в i-ой точке отрезка. Из формулы видно, что за исключением крайних точек все нечетные компоненты имеют одинаковые коэффициенты, равные 4, а все четные компоненты имеют коэффициенты, равные 2.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> Пусть дин процесс вычисляет сумму всех нечетных компонент S1, а второй процесс – сумму всех четных компонент S2 и оба передают значения своих сумм третьему процессу, который вычисляет выражение S=h(4S1+2 S2+f(a)+f(b))/3. Полученная величина является приближенным значением интеграла, если две соседние итерации отличаются больше, чем на заданную величину (eps ), то величина шага уменьшается вдвое и начинается новая итерация. Такие вычисления продолжаются до тех пор, пока не будет достигнута заданная точность.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Синхронизация процессов заключается в том, чтобы накопленные суммы передавались управляющему ( третьему) процессу, когда суммирование компонент полностью завершено.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> Такой подход существенно снижает количество операций умножения, что увеличивает точность и снижает объем вычислений.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t> Ниже приведен текст  программы, которая реализует приближенное интегрирование функции, но только для одного отрезка.</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>with ADA.text_io,ada.integer_text_io,ada.float_text_io;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>use ADA.text_io,ada.integer_text_io,ada.float_text_io;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>with ada.Numerics.Elementary_Functions;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>use  ada.Numerics.Elementary_Functions;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>with ada.Numerics; use ada.Numerics;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>procedure Sim is</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>a, b, eps,Tmp: float;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Sum,k,h : float;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Mas : array (1..2) of float := (0.0,0.0);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>function f (x: float) return float is -- test function</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>begin return 1.0/(1.0+x*x);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end f;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>task type one_proc is</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>entry Set (i: integer);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>entry  Start_p;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>entry  End_p(MAS : out float);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end one_proc;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Event : array (1..2) of one_proc;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>task body one_proc is</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>j : integer;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>x, s : float;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>begin --one_proc</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>accept Set (i: integer) do</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>j :=i;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end Set;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>new_line; put(“ Starting  “);  put(j);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>loop</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>select</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>accept Start_p;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>x := a + h*float(j);  --Start point</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>s :=0.0;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>while x&lt;b  loop</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>s := s + f(x);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>x :=x + 2.0*h;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end loop;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>or</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>accept End_p(Mas : out float) do</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Mas := s;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end End_p;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>or</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>terminate</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end select;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end loop;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end one_proc;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>begin  --Main</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put(“Simpson integral “);  new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put(“First value “);  Get(a);  new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put(“Second value “);  Get(b); new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put(“Epsilon “);  Get(Eps);  new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>for i in 1..2 loop</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Event(i).Set(i);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end loop;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>k:= 1.0;  Tmp :=10.0; Sum :=0.0;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>while ( abs(Tmp-Sum) &gt; Eps ) loop</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>h :=( b-a)/(2.0* k);  k:= k + 1.0;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Tmp := Sum;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>for i in 1..2 loop</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Event(i).Start_p;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end loop;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>for i in 1..2 loop</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Event(i).End_p(Mas(i));</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end loop;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>Sum := (h/3.0)* (f(a) +f(b) + 4.0*Mas(1) +2.0*Mas(2));</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end loop;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>new_line;</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put(“Result : “);</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>put(Sum,5,6 );</w:t></w:r></w:p><w:p><w:pPr><w:spacing w:after="0" w:line-rule="auto"/><w:ind w:first-line="720"/><w:jc w:val="both"/></w:pPr><w:r><w:t>end Sim;</w:t></w:r></w:p>
<w:p><w:pPr><w:ind w:after="0" w:first-line="720"/></w:pPr><w:r><w:t></w:t></w:r></w:p>
</w:body></w:wordDocument>